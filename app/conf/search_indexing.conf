# Field level options
#
#	STORE 			 				(forces value to be stored in index, if possible; this can speed display of the content in a search but may slow down indexing and increases index size)
#	DONT_TOKENIZE	 				(indexes value as-is without tokenization)
#	DONT_INCLUDE_IN_SEARCH_FORM 	(causes field to not be includable in user-defined search forms)
#	BOOST							(numeric "boost" value to index field with; higher values will cause search hits on the boosted field to count for more when sorting by relevance)
#
# Special fields (always start with underscore character):
#	_metadata		(indexes attached ca_attribute_values; you can only specify this for the subject table of an index)
#
#	_count			(embeds the number of related rows for a given table in the index; you can only specify this for non-subject tables; the field is named 
#					 <table_name>_count - for example: object_representations_count for table 'object_representations'; we need this so we can find rows that have, or 
#					 don't have, related rows in a given table. Specifically we need this to implement "show only objects with media" functionality since we can't just
#					 do an INNER JOIN in Lucene as we did in the old SQL-based search engine)
#	_hier_ancestors	(adds a number of specified fields of the ancestors of related rows to the index; oviously this will only work for hierarchical entites like
#					place_names and voc_terms; you can for example specify something like this: _hier_ancestors = { name }; this will force the indexer to look for ancestors
#					of the current subject and add their "name" fields to a virtual field named _hier_ancestors;
#					this - for instance - enables you to find objects related to the place "Madrid" while searching for "Spain")
#					 
# Access point are "virtual fields" for use in searches. They can be employed in three ways:
#	(1) as simple aliases for individual fields. For example, if you wanted to enabled searches on object synonym using objsyn like so: 
#				objsyn:Volkswagen
#		then you'd simply define 'objsyn' to be an access point to objects.synonym
#
#	(2) as aliases for bundles of fields. If an access point is defined to include several fields, then a search on the access point will search all of the included fields at the same time.
#
# Note that all fields included in an access point must be included in the search index - they must appear in the "fields" list in other words. All indexed fields automatically
# have access points created in the format tablename.fieldname (ex. objects.title); indexed metadata also have access points in the format tablename.md_<element_id> (ex. objects.md_5)
#
# When creating an access point you define an access point configuration associative list, then create a key for each access point.

# ------------------------------------------------------------------------------------------------------------
ms_projects = {
	# ------------------------------------
	_access_points = {
		
	},
	# ------------------------------------
	ms_projects = {
		fields = {
			project_id = {prefix = P },
			name = {},
			publication_status = {},
			abstract = {}
		}
	}
	# ------------------------------------
}
# ------------------------------------------------------------------------------------------------------------

ca_list_items = {
	# ------------------------------------
	_access_points = {
		voc = {
			fields = [ca_lists.use_as_vocabulary]
		},
		list_code = {
			fields = [ca_lists.list_code]
		}
	},
	# ------------------------------------
	ca_lists = {
		key = list_id,
		fields = {
			use_as_vocabulary = { STORE, DONT_TOKENIZE },
			list_code = { STORE, DONT_TOKENIZE }
		}
	},
	# ------------------------------------
	ca_list_items = {
		fields = {
			idno = { STORE, DONT_TOKENIZE },
			_metadata = { },
			list_id = { STORE, DONT_TOKENIZE },
			access = { STORE, DONT_TOKENIZE },
			status = { STORE, DONT_TOKENIZE },
			deleted = { STORE, DONT_TOKENIZE }
		}
	},
	# ------------------------------------
	ca_list_item_labels = {
		key = item_id,
		fields = {
			item_id = { DONT_INCLUDE_IN_SEARCH_FORM },
			name_singular = { BOOST = 100 },
			name_plural = { BOOST = 100 }
		}
	}
	# ------------------------------------
}

# ------------------------------------------------------------------------------------------------------------
ca_users = {
	# ------------------------------------
	_access_points = {
		username = {
			fields = [ca_users.user_name]
		}
	},
	# ------------------------------------
	ca_users = {
		fields = {
			user_id = {},
			user_name = {},
			fname = {},
			lname = {},
			email = {}
		}
	}
	# ------------------------------------
}

# ------------------------------------------------------------------------------------------------------------
ca_user_groups = {
	# ------------------------------------
	_access_points = {
		name = {
			fields = [ca_user_groups.name]
		}
	},
	# ------------------------------------
	ca_user_groups = {
		fields = {
			name = {},
			code = {},
			description = {}
		}
	}
	# ------------------------------------
}
# ------------------------------------------------------------------------------------------------------------
